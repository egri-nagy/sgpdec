<#GAPDoc Label="CascadeShell">
<ManSection><Heading>CascadeShell</Heading>
<Oper Name="CascadeShell" Arg="components"/>
<Oper Name="CascadeShell" Arg="components, statesymfuncs, opsymfuncs"/>
<Description>
  <C>CascadeShell</C> builds a cascaded structure from the given list of
  <C>components</C>. The components are either permutation groups or transformation 
  semigroups. The cascaded structure itself is just a framework in which 
  cascaded states and operations can be instantiated, therefore creating a cascaded structure
  is quick while calculating in it may be very computation intensive.
  <P/>
  The symbol functions are lists of functions for each components mapping states and 
  operations to strings. If they are not specified  the functions return the default string
  representations of integer numbers.
<Example>
gap> S := Semigroup([Transformation([2,3,2]),Transformation([1,1,2])]);
&lt;semigroup with 2 generators&gt;
gap> G := Group([(1,2,3),(1,4)]);
Group([ (1,2,3), (1,4) ])
gap> csh := CascadeShell([G,S,G,S,S]);
sg_S4_sg11_S4_sg11_sg11
gap> Display(csh);
1 (4,S4)
2 |-(3,sg11)
3 |-|-(4,S4)
4 |-|-|-(3,sg11)
5 |-|-|-|-(3,sg11)
</Example>
</Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="SizeOfWreathProduct">
<ManSection><Heading>Size of the Wreath Product</Heading>
<Func Name="SizeOfWreathProduct" Arg="cascadeshell"/>
<Description>
Returns the size of the wreath product of the components of the
given cascade shell. The wreath product is the biggest cascaded structure
that can be built in a shell.
<Example>
gap> C2 := CyclicGroup(IsPermGroup,2);
Group([ (1,2) ])
gap> csh := CascadeShell([C2,C2,C2]);
G_C2_C2_C2
gap> Display(csh);
1 (2,C2)
2 |-(2,C2)
3 |-|-(2,C2)
gap> SizeOfWreathProduct(csh);
128
</Example>
</Description>
</ManSection>
<#/GAPDoc>


<#GAPDoc Label="NumberOfDependencyFunctionArguments">
<ManSection><Heading>The number of dependency function arguments</Heading>
<Func Name="NumberOfDependencyFunctionArguments" Arg="cascadeshell"/>
<Description>
Returns the number of all possible dependency function arguments across all
levels.
<Example>
gap> C2 := CyclicGroup(IsPermGroup,2);
Group([ (1,2) ])
gap> C3 := CyclicGroup(IsPermGroup,3);
Group([ (1,2,3) ])
gap> NumberOfDependencyFunctionArguments(CascadeShell([C3]));
1
gap> NumberOfDependencyFunctionArguments(CascadeShell([C3,C2]));
4
gap> NumberOfDependencyFunctionArguments(CascadeShell([C3,C2,C3]));
10
gap> NumberOfDependencyFunctionArguments(CascadeShell([C3,C2,C3,C2]));
28
</Example>
</Description>
</ManSection>
<#/GAPDoc>

      <#GAPDoc Label="MonomialGenerators">
      <ManSection><Heading>Constructing monomial generators for the wreath product</Heading>
      <Func Name="MonomialGenerators" Arg="cascadedstruct"/>
      <Description>
      The wreath product (the full structure on the given components) can be generated by
      monomial generators, i.e. cascaded operations containing only one elementary dependence.
      For cascades of groups it returns a minimal set of monomial generators, but for semigroups it may not.
      </Description>
      </ManSection>
      <#/GAPDoc>
