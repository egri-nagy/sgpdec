# ALPHABETICAL ORDER (by label)

<#GAPDoc Label="DependencyDomains">
  <ManSection>
    <Func Name="DependencyDomains" Arg="list"/>
    <Returns>The domains of the dependency function in a list of
    lazily evaluated list enumerators.
    </Returns>
    <Description>
The argument <A>list</A> can be a list of
<List>
<Item> of positive integers, the cardinalities of the component's state sets,</Item>
<Item> the state sets,</Item>
<Item> the components, domain sizes are inferred in this case by using  <Ref Attr="DegreeOfTransformationSemigroup" BookName="ref"/> and <Ref Attr="LargestMovedPoint" BookName="ref"/>.</Item>
</List>

<Example>
gap> G := SymmetricGroup(IsPermGroup, 3);
Sym( [ 1 .. 3 ] )
gap> S := Semigroup([Transformation([2,2,4,4]),Transformation([3,2,3,2])]);
&lt;transformation semigroup on 4 pts with 2 generators&gt;
gap> dd1 := DependencyDomains([G,S]);
[ [ [  ] ], &lt;enumerator&gt; ]
gap> dd2 := DependencyDomains([3,4]);
[ [ [  ] ], &lt;enumerator&gt; ]
gap> dd3 := DependencyDomains([[1..3],[1..4]]);
[ [ [  ] ], &lt;enumerator&gt; ]
gap> dd1 = dd2 and dd2  = dd3;
true
</Example>

The <M>n</M>th dependency domain is the direct product of the state sets of the first <M>n-1</M> components.
<Example>
gap> depdoms := DependencyDomains([3,2,2]);
[ [ [  ] ], &lt;enumerator&gt;, &lt;enumerator&gt; ]
gap> AsList(depdoms[1]);
[ [  ] ]
gap> AsList(depdoms[2]);
[ [ 1 ], [ 2 ], [ 3 ] ]
gap> AsList(depdoms[3]);
[ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 2 ], [ 3, 1 ], [ 3, 2 ] ]
</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DependencyFunction">
  <ManSection>
    <Func Name="DependencyFunction" Arg="depdom, deps"/>
    <Returns>A dependency function on domain <A>depdom</A> with
non-identity values defined in the list of dependencies <A>deps</A>.
    </Returns>
    <Description>
      The dependencies are given in <C>[argument,value]</C> format.
<Example>
gap> depdoms := DependencyDomains([2,3]);
[ [ [  ] ], &lt;enumerator&gt; ]
gap> df := DependencyFunction(depdoms[1], [[[],(1,2)]] );
&lt;depfunc of depth 1 with 1 deps&gt;
gap> Display(df);
Dependency function of depth 1 with 1 dependencies.
[ ] -&gt; (1,2)
gap> df2 := DependencyFunction(depdoms[2], [[[1],(1,3)], [[2],(1,2)]] );
&lt;depfunc of depth 2 with 2 deps&gt;
gap> Display(df2);
Dependency function of depth 2 with 2 dependencies.
[ 1 ] -&gt; (1,3)
[ 2 ] -&gt; (1,2)
</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DependencyFunctionAttributes">
  <ManSection> <Heading>Attributes of dependency functions</Heading>
<Attr Name="DomainOf" Arg="depfunc"/>
    <Returns>The dependency Domain</Returns>
<Attr Name="NrDependencies" Arg="depfunc"/>
    <Returns>The number of non-identity dependency values.</Returns>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="EvalWordInSkeleton">
  <ManSection>
    <Func Name="EvalWordInSkeleton" Arg=""/>
    <Returns>The transformation represented by the given word.</Returns>
    <Description>
In the skeleton transformation are often represented as lists of integers indexing the generators, the so called <E>words</E>.
This function evaluates of a word in the skeleton. Added for convenience, no sanity check is done at the moment.
<Example>
gap> T := FullTransformationMonoid(4);
&lt;full transformation semigroup on 4 pts&gt;
gap> Generators(T);
[ Transformation( [ 2, 3, 4, 1 ] ), Transformation( [ 2, 1 ] ), 
  Transformation( [ 1, 2, 3, 1 ] ) ]
gap> sk := Skeleton(T);;
gap> EvalWordInSkeleton(sk,[]);
()
gap> EvalWordInSkeleton(sk,[1]);
Transformation( [ 2, 3, 4, 1 ] )
gap> EvalWordInSkeleton(sk,[2]);
Transformation( [ 2, 1 ] )
gap> EvalWordInSkeleton(sk,[3]);
Transformation( [ 1, 2, 3, 1 ] )
gap> EvalWordInSkeleton(sk,[1,2,3]);
Transformation( [ 1, 3, 1, 2 ] )
</Example>
    </Description>
  </ManSection>
<#/GAPDoc>


<#GAPDoc Label="OnDepArg">
  <ManSection> <Heading>Evaluating dependency functions</Heading>
<Func Name="OnDepArg" Arg="arg, depfunc"/>
    <Returns>The value of the dependency function on the given argument.</Returns>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnFiniteSet">
  <ManSection> <Heading>Acting on finite sets</Heading>
<Func Name="OnFiniteSet" Arg="finset, transformation"/>
    <Returns>finite set.</Returns>
<Description>
<Example>
gap> SgpDecFiniteSetDisplayOn();
gap> P := FiniteSet([2,3]);
{2,3}
gap> t := Transformation([1,1,4,3]);;
gap> OnFiniteSet(P,t);
{1,4}
gap> SgpDecFiniteSetDisplayOff();
gap> OnFiniteSet(P,t*t);
[ true, false, true ]
</Example>
</Description>
  </ManSection>
<#/GAPDoc>


<#GAPDoc Label="SgpDecMakeDoc">
  <ManSection>
    <Func Name="SgpDecMakeDoc" Arg=""/>
    <Returns>Nothing.</Returns>
    <Description>
      This function should be called with no argument to compile the
      &SgpDec; documentation.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SgpDecRunManualExamples">
  <ManSection>
    <Func Name="SgpDecRunManualExamples" Arg=""/>
    <Returns>Nothing.</Returns>
    <Description>
      This function runs the examples from the manual to make
      sure that the documentation is in line with the actual implementation.
      This an alternative way to test the installation's correctness.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SgpDecTestInstall">
  <ManSection>
    <Func Name="SgpDecTestInstall" Arg=""/>
    <Returns>Nothing.</Returns>
    <Description>
      This function should be called with no argument to comprehensively
      test that &SgpDec; is working correctly. These tests
      should take no more than a few minutes to complete.
    </Description>
  </ManSection>
<#/GAPDoc>
