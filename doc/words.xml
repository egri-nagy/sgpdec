<#GAPDoc Label="Construct">
<ManSection>
  <Oper Arg="word, generators, start, action" Name="Construct" />
  <Oper Arg="word, generators, start, action" Name="ConstructWithInverses" />
  <Oper Arg="word, generators, start, action" Name="Trajectory" />
  <Oper Arg="word, generators, start, action" Name="TrajectoryWithInverses" />
  <Description>
General purpose function for constructing some structure by applying generators
in the order coded defined by a sequence of integers (words).
The construction starts at the given element, and the action should be a
function describing how the generators act on the starting and the subsequent
points. For an empty word the starting point is returned. Trajectory is the same
but it returns the whole calculation, not just the final result.
<P></P>
These functions can be considered to be the generalizations of <Package>Citrus'
</Package> <Code>EvaluateWord</Code>.
<P></P>
Calculating a transformation represented by a word:
<Example>
gap> gens := [Transformation([2,3,4,1]),
> Transformation([2,1,3,4]),
> Transformation([1,1,3,4])];;
gap> Construct([1,2,1,2,3],gens,IdentityTransformation(4),\*);
Transformation( [ 1, 4, 1, 3 ] )
</Example>
    Or acting on some set:
    <Example>
gap> Construct([1,2,1,2,3],gens,[1,2],OnSets);
[ 1, 4 ]
</Example>
    For invertible generators (e.g. permutations), negative integers can be used
    for coding inverses:
    <Example>
gap> ConstructWithInverses([1,-1],[(1,2)],(),\*);
()
</Example>
    The next archetypical programming example demonstrates the flexibility of
these functions:
    <Example>
gap> Construct([3,5,9,9,4,6,2,4,8,9,7,1],
> ["!","W","H","o","e"," ","d","r","l"],
> "",
> Concatenation);
"Hello World!"
</Example>
    Or we can have the intermediate elements of the construction.
    <Example>
gap> Trajectory([3,2,1],["c","b","a"],"",Concatenation);
[ "", "a", "ab", "abc" ]
</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsStraightWord">
<ManSection >
  <Oper Arg="word, gens, start, action" Name="IsStraightWord" />
  <Description>
Returns true if the word generates a trajectory that is straight starting
from the given point, i.e. there are no repeated visited nodes.
<Example>
gap> w := [1,2,1,2,1,2,1,2];
[ 1, 2, 1, 2, 1, 2, 1, 2 ]
gap> Trajectory(w, [(1,2),(1,2,3)],(),\*);
[ (), (1,2), (1,3), (1,3,2), (), (1,2), (1,3), (1,3,2), () ]
gap> IsStraightWord(w, [(1,2),(1,2,3)],(),\*);
false
</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Reduce2StraightWord">
<ManSection >
  <Func Arg="word, gens, start, action" Name="Reduce2StraightWord" />
  <Description>
Returns the straight word yielded by the reduction (cutting out identities
and repetitions). The algorithm takes the trajectory and compares the elements
from the beginning and from the end.
<Example>
gap> w := [1,2,1,2,1,2,1,2];
[ 1, 2, 1, 2, 1, 2, 1, 2 ]
gap> rw := Reduce2StraightWord(w, [(1,2),(1,2,3)],(),\*);
[ 1, 2, 1, 2 ]
gap> Trajectory(rw, [(1,2),(1,2,3)],(),\*);
[ (), (1,2), (1,3), (1,3,2), () ]
gap> IsStraightWord(rw, [(1,2),(1,2,3)],(),\*);
true
</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="SymbolicInverse">
<ManSection>
  <Oper Arg="word" Name="SymbolicInverse" />
  <Description>
Inverts the word as a product of permutations.
The order is reversed  and the indices are multiplied by -1, corresponding to
the way of encoding inverse permutations.
<Example>
gap> SymbolicInverse([2,1,-2]);
[ 2, -1, -2 ]
</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="SymbolicReduced">
<ManSection>
  <Oper Arg="word" Name="SymbolicReduced" />
  <Description>
    Symbolically reduces the word, i.e. cancelling neighbouring inverses.
<Example>
gap> SymbolicReduced([1,-1,2,-3,3]);
[ 2 ]
gap> SymbolicReduced([-2,1,-1,2,-3,3]);
[  ]
</Example>
  </Description>
</ManSection>
<#/GAPDoc>